"""
@Date: Saturday, March 13, 2021
@Author: Chen Zhang
@Brief: 动态规划练习题-鸡蛋掉落（困难）

问题描述：
    https://leetcode-cn.com/problems/super-egg-drop/solution/ji-dan-diao-luo-by-leetcode-solution-2/
"""
from math import floor


def myDropEgg(K, N):
    """
    输入楼层的高度，输出确定F值（鸡蛋掉落不会破碎的最高楼层）的最小移动次数。

    我的原始思路：
        使用二叉搜索的思路。令fN为从N层楼中确定F所需的最小移动次数。
        若N=1，则f1 = 1；
        若N=2，则f2 = 2;
        若N=3，则首先移动到第(N+1)/2=2层抛下鸡蛋，若鸡蛋没碎，则2层以下确定不包含F，向上搜索还剩1层，同时
        也还需移动1次才能确定F（移动到第三层抛鸡蛋，若没碎则F=3，否则F=2）；若鸡蛋碎了，则2层以上确定不包
        含F，向下搜索还剩1层，同时也还需移动1次才能确定F（移动到第一层抛鸡蛋，若没碎则F=1，否则F=0）
        总结可知，f3=1+f1=2。

        若N=4，由于（N+1)/2=2.5，分两种情况讨论：
            第一种情况：首先移动到第2层抛下鸡蛋，若鸡蛋没碎，则2层以下确定不包含F，向上搜索还剩2层，同时还
            需至少移动2次才能确定F（【1】首先移动到3层抛鸡蛋，若鸡蛋碎了则F=2，否则移动到第4层抛鸡蛋，若鸡蛋
            碎了则F=3，否则F=4；【2】首先移动到4层抛鸡蛋，若鸡蛋没碎则F=4，否则移动到第3层抛鸡蛋，若鸡蛋没碎
            则F=3，否则F=2。两种情况都需要2次移动，正好等于f2的值）；若鸡蛋碎了，则2层以上确定不包含F，向下
            搜索还剩1层，需要移动1次才能确定F值（正好等于f1值）。
            第二种情况：首先移动到第3层抛下鸡蛋，若鸡蛋没碎，则3层以下确定不包含F，向上搜素还剩1层，同时还需移
            动至少1次才能确定F（正好等于f1值）；若鸡蛋碎了，则3层以上确定不包含F，向下搜序还剩2层，同时还需移
            动至少2次才能确定F（正好等于f2值）。
        总结可知，f4=max(1+f1, 1+f2)=3。

        若N=5，则首先移动到第(N+1)/2=3层抛下鸡蛋，不管鸡蛋是否碎了，都至少需要向上或向下移动2次才能确定F（正
        好等于f2值），总结可知，f5=1+f2=3。

        若N=6，由于(N+1)/2=3.5，又要分两种情况讨论：
            第一种情况：首先移动到第3层抛下鸡蛋，若鸡蛋没碎，则3层以下不包含F，向上搜索剩3层，推演后可知对3层
            使用二叉搜索方法会得到最小的移动步数2（等于f3）；若鸡蛋碎了，则3层以上不包含F，向下搜索还剩2层，
            至少需要移动2步才能确定F，即f6=max(1+f3, 1+f2)。
            第二种情况：首先移动到第4层抛下鸡蛋，若鸡蛋没碎，则4层以下不包含F，向上搜索还剩2层，至少需要移动
            2步才能确定F；若鸡蛋碎了，则4层以上不包含F，向下搜索还剩3层，推演后可知对3层使用二叉搜索方法会得
            到最小的移动步数2才能确定F（等于f3），即f6=max(1+f2, 1+f3)。
        总结可知，f6=max(1+f2, 1+f3)=3

    优化后的解释：
        使用二叉搜索的思路。较多楼层需要的搜索次数不会少于较少楼层。
        首先移动到floor(N/2)层抛下鸡蛋(floor()为向下取整)，
        若鸡蛋没碎：
            floor(N/2)层以下不包含F，向上继续搜索还剩M1+1=N-floor(N/2)+1层。将这M1层单独抽取出来，
            首先关注M1层中的最底层（也即第floor(N/2)层），由于该层抛下鸡蛋不会碎，因此该层是不是F
            层就取决于它向上一层，若上一层抛下鸡蛋会碎，则该层即为F层，否则不是。根据抽出的M层中的
            最底层的特点可知，它与原始问题中的第0层性质相同，因此在这M1+1层搜索F等价于在一栋M1层高的楼
            中搜索F。由此可知，f_N = 1 + f_M1，其中M1=N-floor(N/2)。
        若鸡蛋碎了：
            floor(N/2)层及以上不包含F，抽取出剩下的M2=floor(N/2)-1层继续搜索F，等价于在一栋M2层高
            的楼中搜素F。由此可知, f_N = 1 + f_M2，其中M2=floor(N/2)-1。
        由于是二叉搜索，因此M1=N-floor(N/2)=floor(N/2)，故M1>=M2。由于较多楼层需要的搜索次数不会少
        于较少楼层，因此f_N = 1 + f(floor(N/2))。结合N=1与N=2的特殊情况可以得到状态转移方程。

    由此得到状态转移方程：
                    fN = 1, N=1
                    fN = 2, N=2
                    fN = 1 + f(floor(N/2)), N>2

    :param N: 楼层的高度。
    :return: 移动次数。
    """

    if N == 1:
        return 1
    elif N == 2:
        return 2
    else:
        return 1 + myDropEgg(floor(N/2))


class Solution:
    def superEggDrop(self, k: int, n: int) -> int:
        def parse(k, n):
            if n == 1:  # 如果只有1层，不管有多少蛋只需试1次
                return 1
            elif n == 0:
                return 0
            elif k == 1:  # 只有1个鸡蛋，则只能逐层试
                return n
            elif (k, n) in table:
                return table[(k, n)]

            f = float('inf')
            lp = 0
            rp = n
            while lp <= rp:
                mid = lp + (rp - lp) // 2  # 二分法优化
                bcase = parse(k - 1, mid - 1)  # 蛋碎的情况
                notbcase = parse(k, n - mid)  # 不碎的情况
                # fx = 1 + max(bcase, notbcase)
                if bcase > notbcase:
                    rp = mid - 1
                    f = min(f, bcase + 1)
                else:
                    lp = mid + 1
                    f = min(f, notbcase + 1)

            table[(k, n)] = f
            return f

        table = {}  # 记忆被计算过的情况
        return parse(k, n)


if __name__ == '__main__':
    N = 14
    print('%d层楼需要移动至少%d次才能确定F' % (N, myDropEgg(N)))
