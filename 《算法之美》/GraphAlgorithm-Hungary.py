"""
@Date: Friday, March 19, 2021
@Author: Chen Zhang
@Brief: 匈牙利算法（图算法） - 寻找二部图中最大匹配的算法。

算法例题：https://www.nowcoder.com/practice/b9eae162e02f4f928eac37d7699b352e?tpId=37&tqId=21251&rp=1&ru=%2Fta%2Fhuawei&qru=%2Fta%2Fhuawei%2Fquestion-ranking&tab=answerKey
算法解释：https://blog.csdn.net/u013384984/article/details/90718287

匈牙利算法简介：
    1、图的一个匹配：由一组没有公共端点的不是圈的边构成的集合（图的顶点之间两两配对）；
    2、二部图：将图中顶点分为两组，组内的任意顶点之间没有边连接，只有两个组之间存在边的连接的图；
    3、完美匹配：二部图中可以为其中某个组中所有的顶点找到配对的顶点；
    4、最大匹配：在不能达到完美匹配的前提下找到最大的匹配；
    5、交错路径：给定图的一个匹配M，如果某条路径的边交错出现在给定的匹配M中和不出现在给定的匹配M
        中，则该路径为M-交错路径；
    6、扩增路径：如果一条“M-交错路径”，它的两个端点都不与M中的边关联（不是匹配M中的任何边的顶点），
        那么该条M-交错路径叫做“M-增广路径”；
    7、若对于给定图的匹配中找到一条增广路径，则可以通过重新匹配的方式增加匹配的边数，当图中不再有
        增广路径时，即找到了该图的最大匹配；
    8、匈牙利算法的核心：递归地寻找图中的现有匹配的增广路径。

素数伴侣问题：
        若两个正整数的和为素数，则这两个正整数称之为“素数伴侣”，如2和5、6和13，它们能应用于通信加密。
    现在密码学会请你设计一个程序，从已有的N（N为偶数）个正整数中挑选出若干对组成“素数伴侣”，挑选
    方案多种多样，例如有4个正整数：2，5，6，13，如果将5和6分为一组中只能得到一组“素数伴侣”，而将
    2和5、6和13编组将得到两组“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案”，当然密码学会
    希望你寻找出“最佳方案”。

    输入:
        有一个正偶数N（N≤100），表示待挑选的自然数的个数。后面给出具体的数字，范围为[2,30000]。
        说明：
            1 输入一个正偶数n：4
            2 输入n个整数：2 5 6 13
    输出:
        输出一个整数K，表示你求得的“最佳方案”组成“素数伴侣”的对数。
        说明：
            求得的“最佳方案”组成“素数伴侣”的对数：2
"""


def issu(x):
    """
    判断x是否为素数
    """
    tem = 2
    while tem ** 2 <= x:
        if x % tem == 0:
            return False
        tem += 1
    return True


def find(a, l1, l2, l3):
    """
    寻找扩增路径。

    由于增光路径的两个与匹配不相关的点必定位于两个不同的部，因此在未匹配过的偶数中
    寻找可以与未匹配的奇数a组合的点，抽象地模拟了在已有图的匹配的基础上寻找增广路
    径的过程。

    :param a: 奇数部中未匹配的点
    :param l1: 已经匹配过的偶数部中的点
    :param l2: 存放对应位置偶数匹配的奇数值
    :param l3: 偶数部
    :return:
    """
    for i in range(0, len(l3)):  # 在偶数部中搜索
        if issu(a+l3[i]) and l1[i] == 0:  # 若找到奇数a的一个匹配偶数，并且该偶数点为“未匹配”状态
            l1[i] = 1  # 将该偶数与奇数a匹配，将该偶数点标记为“已匹配”
            if l2[i] == 0 or find(l2[i], l1, l2, l3):
                # 若该偶数之前没有相匹配的奇数，或对该偶数之前匹配的奇数点又找到了新的可匹配偶数
                # 此处递归地为先前已经匹配过的奇数寻找新的匹配的可能，若每一个都找到了新的匹配，
                # 则更新匹配的边，否则不更新。
                l2[i] = a  # 重置该偶数匹配的奇数为a
                return True
    return False


if __name__ == '__main__':
    try:
        while True:
            n = input()  # 输入正整数（偶数）
            n = int(n)
            l = list(map(int, input().split()))  # 输入n个待匹配正整数

            # 由于素数除2以外全部是奇数，因此除2以外素数的素数伴侣必定
            # 是有一个奇数加一个偶数构成，因此在最大匹配中的奇数之间不可
            # 能有边连接，可以抽象为一个二部图，使用匈牙利算法寻找最大匹配。

            ji, ou = [], []  # 存放l中的奇数和偶数
            for i in range(n):
                if l[i] % 2 == 0:
                    ou.append(l[i])
                else:
                    ji.append(l[i])

            result = 0  # 记录最大匹配的边数
            match = [0] * len(ou)  # 存放相同下标的偶数部的偶数所匹配的奇数的值
            for i in range(0, len(ji)):  # 在奇数中搜索
                used = [0] * len(ou)  # 临时存放匹配过程中，偶数是否“已匹配”
                if find(ji[i], used, match, ou):  # 寻找扩增路径
                    result += 1
            print(result)
    except:
        pass
